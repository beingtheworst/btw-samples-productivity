# Domain Driven Design
A collection of guidelines and modeling tools with focus on analyzing and modeling the core of business problem and related processes. Beware, you will have to understand domain you're working with in depth, which usually requires a lot of time (often due to a large number of details that are not apparent initially).

##Domain
Logical group of closely related processes and their specific (ubiquitous) language. For example different departments in an organization would usually reside in their own domain. Typically in an organization there's Core Domain which is surrounded by Support Domains.

##Bounded Context (BC)
Explicit boundary around processes modeled in the code. Ideally BC isolates real-world problem space (based on language, etc.) there should be 1-to-1 correlation between domain and BC. In mane projects developers tend to put too many domains into one BC, resulting in mixing code related to different domains often leading to a big ball of mud.

##Core Domain
Main domain from which value of the organization or project is derived. For example in a business core domain is the part of organization which distinguishes it from other business and leads to earning money.

##Support Domains
Domains focused on supporting (helping) Core Domain to ensure it functions not just correctly, but as optimally as it can.

#Command Query Responsibility Segregation (CQRS)
Software design pattern in which code reading data from storage is consciously kept separate from the code which writes data to a storage. In many systems, especially as they become more complex, writing data and reading data require different approaches (both for optimization and to keep code simple). Keeping them separate allows each piece of code to focus on the read or write specific needs. The term was first coined by Greg Young and is based off CQS (Command Query Separation). Watch http://www.youtube.com/watch?v=KXqrBySgX-s for more details.

#Event Sourcing

An idea of capturing everything that happens in the system in a stream of events. Thus no information is ever lost. When current (or not) state of the system is needed, events are replayed in the order they happened in the past until information we're interested in is generated.

##Message
Information in the form which allows it to be transferred from one location to another. A letter would be an example of a message in the physical world.

##Envelope
Wrapper around message which provides facilities to identify the message, prevent (or at least check for) corruption, etc.

##Command
Message with request to perform some operation by the system. In synchronous environment command can be rejected by the system (for example if it's invalid). In asynchronous environment command is always accepted, and if there's an issue with command a special event can be issued in response.

##Event
Message with historical information about what happened. In many cases events are generated in response to commands, when they're processed. In some circumstances event can come from outside the system notifying the system what happened in the outside world. Events are immutable. Once they're published they cannot be modified. If there's a problem a compensating command needs to be issued to fix the problem.

##Message Queue
Robust first in - first out stream of commands and events used for communication between different parts of the system. Usually guarantees at least once message delivery (so some form of deduplication needs to take place).

##Event Stream (aka Tape)

An append only stream of messages. Used to record events to be replayed at a later date.

##View
State of the system generated by replaying events.

##Projection
A set of rules on how to process events to generate a view.